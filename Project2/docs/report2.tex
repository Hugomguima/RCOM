\documentclass[11pt]{article}

\usepackage[english]{babel}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage[section]{placeins}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{float}
\usepackage{capt-of}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\lstdefinestyle{bashStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=bash
}


\begin{document}

\begin{titlepage}
	\begin{center}
		\vspace*{1cm}
		
		\Large
		\textbf{Rede de Computadores}
		
		\vspace{0.5cm}
		\large
		Segundo Trabalho Laboratorial
		
		\vspace{1.5cm}
		
		\textbf{Hugo Miguel Monteiro Guimarães}\\
		\textbf{Pedro Varandas da Costa Azevedo da Ponte}
		
		\vspace{5cm}
		
		Trabalho realizado no âmbito da\\
		Unidade Curricular de Redes de Computadores
		
		\vspace{0.8cm}
	
		\includegraphics[width=0.4 \textwidth]{feup_logo.png}
		
		\vspace{1.5cm}		
		
		\large
		Mestrado Integrado em Engenharia Informática e Computação\\
		Faculdade de Engenharia da Universidade do Porto\\
		Porto\\
		23 de dezembro de 2020
	
	\end{center}
\end{titlepage}


\pagebreak
\tableofcontents

\pagebreak


\section*{Sumário}
Este trabalho foi realizado no contexto da cadeira Redes de Computadores, com o objetivo de implementar uma aplicação segundo o protocolo \emph{FTP}, permitindo descarregar um ficheiro a partir de um determinado url.
 
Deste modo, o trabalho foi concluído com sucesso, dado que foi possível implementar uma aplicação que cumprisse os objetivos estabelecidos.


\section{Introdução}
Este trabalho está dividido em 2 partes, sendo a primeira responsável pelo \emph{download} de um ficheiro segundo o protocolo \emph{FTP} e segunda a configuração e análise de uma rede

O relatório pretende descrever detalhadamente a aplicação implementada, estando dividida nas seguintes secções:
\begin{description}
	\item[Parte 1 -] Arquitetura da aplicação de \emph{download} de um ficheiro e os respetivos resultados.
	\item[Parte 2 -] Configuração da rede e análise das seis experiências executadas de acordo com o guião fornecido.
	\item[Conclusões - ] Síntese da informação apresentada nas secções anteriores e reflexão sobre os objetivos de aprendizagem alcançados.
\end{description}


\section{Parte 1 - Aplicação de Download}
A primeira parte deste trabalho consistiu em desenvolver uma aplicação de \emph{download} na linguagem de programação C. Para correr a aplicação, basta compilar os ficheiros usando o \emph{Makefile} e depois correr o comando \textbf{./download ftp://[$<$user$>$:$<$password$>$@]$<$host$>$/$<$url-path$>$}. Esta aplicação permite fazer o \textit{download} de ficheiros a partir de um servidor do tipo \textbf{FTP}

\subsection{Arquitetura}
Para desenvolver a aplicação, decidimos dividi-la em duas partes: a primeira faz o processamento dos argumentos introduzidos no terminal e que vão ser utilizados para a transferência. A segunda parte é responsável pela conexão ao servidor para que se possa obter o ficheiro desejado.

Para processar os argumentos, desenvolvemos a função \textit{\textbf{parseArguments}}, que divide o argumento nos seus vários componentes: \emph{username, password, host name, path e filename}. Estes componentes vão ser armazenados numa \textit{struct} \textit{\textbf{arguments}} por nós criada, que vai ser acedida depois para que a transferência do ficheiro ocorra.

Para implementar a segunda parte, primeiramente temos de obter o endereço IP a que o \emph{host} está associado. Para isso, recorremos à função \textit{\textbf{getIP}}, que utilizando maioritariamente código fornecido num exemplo das aulas teórico-práticas, obtém o IP, estando desta forma aptos a iniciar a conexão com o host. De seguida, chama-se a função \textit{\textbf{initConnection}}, que utilizando novamente código fornecido nas aulas, é responsável por ligar o cliente FTP ao servidor através de um \textit{socket}, utilizando-se a porta 21.

Após a conexão estar estabelecida, envia-se então o primeiro comando "\textbf{USER} 'username'\textbackslash r\textbackslash n" através da função \textit{\textbf{sendData}}, esperando-se pela resposta usando a função \textit{\textbf{receiveAnswer}}. No caso de ser a resposta esperada, envia-se entao o comando "\textbf{PASS} 'password'\textbackslash r\textbackslash n", esperando-se novamente pela resposta do servidor para se poder prosseguir.

As chamadas à função \textit{\textbf{receiveAnswer}} podem retornar essencialmente 3 tipos de respostas diferentes que importa clarificar:

\begin{itemize}
    \item \textbf{Códigos começados por 2 -} Respostas positivas, ou seja, a operação realizada pelo comando enviado foi efetuada com sucesso;
    \item \textbf{Códigos começados por 3 -} Respostas intermédias positivas, ou seja, a operação é válida, mas são necessárias mais informações para que o pedido seja terminado;
    \item \textbf{Códigos começados por 5 -} Respostas negativas, ou seja, ocorreu um erro quando o comando foi enviado.
\end{itemize}

De seguida, são enviados os comandos \textbf{PASV}, que permite entrar no modo passivo e que retorna o endereço IP e a porta para que se possa iniciar um novo \emph{socket} que será responsável pela troca de dados, e "\textbf{RETR} 'path\textunderscore to\textunderscore file\textbackslash r\textbackslash n'", sendo de seguida feito o \emph{download} do ficheiro desejado através da função \textit{\textbf{downloadFile}}. 

Após a transferência estar finalizada, as ligações são fechadas e a aplicação termina.

\subsection{Resultados}

O programa foi testado tanto em modo anónimo como em modo não anónimo, transferindo-se variados ficheiros de diferentes tamanhos e extensões, tendo o programa funcionado corretamente. Caso o ficheiro não exista, seja inválido ou tenha ocorrido algum erro no estabelecimento das ligações ou no envio dos comandos, o programa termina, sendo retornada uma mensagem de erro. 

Ao longo da execução do programa vão sendo imprimidas no terminal diversas mensagens para que seja mais fácil ao utilizadpr acompanhar o desenvolvimento do programa.

\section{Parte 2 - Configuração da Rede e Análise} 

\subsection{Experiência 1 - Configuração de uma rede IP}

O objetivo desta experiência é ligar o tux23 ao tux24 através de um \textit{switch}, configurando os endereços de IP destes 2 computadores para que eles possam comunicar entre si.

Para a configuração dos endereços IP utilizou-se o comando \textit{\textbf{ifconfig eth0 $<$ip$>$}}, sendo atribuído ao tux23 o IP 172.16.20.1 e ao tux24 o endereço 172.16.20.254. De seguida executa-se o comando \textit{\textbf{ping}} seguido do IP do tux24 para verificar a existência de uma ligação entre os dois computadores. 

O comando \textit{\textbf{ping}} gera pacotes de dois tipos: \textbf{ARP} (\textit{Address Resolution Protocol}) e \textbf{ICMP} (\textit{Internet Control Message Protocol}).

Para enviar uma trama para um computador na rede, o emissor (tux23) primeiro necessita de conhecer o endereço MAC correspondente ao endereço IP do recetor (tux24). Para isso, inicialmente envia um pacote \textbf{ARP} em \textit{broadcast} \textit{(ver Figura 1)}, que contém os seus próprios endereços IP e MAC (172.16.20.1 e 00:21:5a:5a:78:c7, respetivamente) e os endereços IP e MAC do outro computador (respetivamente, 172.16.20.254 e 00:00:00:00:00:00 - desconhecido) \textit{(ver Figura 2)} e espera receber como resposta um pacote semelhante, mas no qual o emissor é o tux24 e o recetor é o tux23, e o enderço MAC do tux24 ja se encontra preenchido (00:22:64:a7:26:a2) \textit{(ver Figura 3)}. Assim, o \textbf{ARP} é um protocolo utilizado para a conversão de endereços da camada da \textit{internet} (endereços IP) em endereços da camada de ligação de dados (endereços MAC). 

Conhecidos então os endereços dos \textit{tuxys}, o comando \textit{\textbf{ping}} passa a enviar pacotes \textbf{ICMP}, que transfere mensagens de controlo entre endereços IP. Estes pacotes contêm tanto os endereços IP e MAC do emissor como do recetor \textit{(ver Figura 4)}.

Para se determinar o tipo de trama recebida, é necessário analisar o \textit{Ethernet header}. Caso o valor da variável \textit{type} seja 0x0806, então trata-se de uma trama do tipo \textbf{ARP} \textit{(ver Figura 5)}. Caso o valor seja 0x0800, então trata-se de uma trama \textbf{IP}, podendo-se analisar o respetivo \textit{IP header}. Caso o seu valor seja 1, significa que se trata de uma trama \textbf{ICMP} \textit{(ver Figura 6)}.

O tamanho da trama recebida pode ser obtido analisando-a no \textit{Wireshark}, no bloco do \textit{Frame} \textit{(ver Figura 7)}.

A interface \textit{loopback} é uma interface de rede virtual que o computador utiliza para comunicar com ele próprio, com o objectivo de realizar testes de diagnóstico, ou aceder a servidores na própria máquina, como se fosse um cliente.

\subsection{Experiência 2 - Implementação de 2 VLANs no SWITCH}

O objetivo desta experiência é criar duas \textit{LANs} virtuais no \textit{switch}, sendo uma constituída pelo tux23 e pelo tux24 (\textit{vlan20}) e outra formada pelo tux22 (\textit{vlan21}). Desta forma, as máquinas 3 e 4 deixam de ter acesso à máquina 2 pois encontram-se em sub-redes diferentes.

Para se configurar a \textit{vlan20}, recorreu-se ao código que se encontra no anexo(INSERIR INDEX AQUI) 

De seguida, é necessário adicionar os respetivos \textit{tuxys} a esta \textit{VLAN}. Tendo em consideração que o tux23 está ligado à porta 1 do \textit{switch} e o tux24 na porta 2, a adição das portas á VLan pode ser vista no anexo(INSERIR INDEX AQUI) 

Depois da \textit{vlan21} estar configurada, envia-se o comando \textit{ping} do tux23 para o tux24 e depois para o tux22, sendo a seguir enviado o comando \textit{ping broadcast} a partir do mesmo tux.

De seguida, analisam-se os respetivos registos no \textit{Wireshark}, concluindo-se que existem dois domínios \textit{broadcast}. O tux23 recebe resposta do tux24 quando executa o comando \textit{ping broadcast}, mas não do tux22, assim como o tux22 não recebe resposta de nenhum dos outros \textit{tuxys} quando executa esse comand, pois estão ligados a sub-redes diferentes. Assim, existem dois domínios de \textit{broadcast}: a \textit{vlan20} e a \textit{vlan21}. 

\subsection{Experiência 3 - Configuração de um Router em Linux}

Nesta experiência, estabeleceu-se uma ligação entre as duas VLANs criadas anteriormente através da configuração do tux24 como um \textit{router}.

Para comunicar entre os \textit{tuxys}, foi necessário adicionar rotas em cada computador, sendo o resultado final o seguinte:

Tux22:
\begin{itemize}
\item Rota para a VLan0 (172.16.20.0) através da gateway 172.16.21.253
\item Rota para a VLan1 (172.16.21.0) através da gateway 0.0.0.0 (default)

\end{itemize}

Tux23:
\begin{itemize}
\item Rota para a VLan0 (172.16.20.0) através da gateway 0.0.0.0 (default)
\item Rota para a VLan1 (172.16.20.0) através da gateway 172.16.21.254

\end{itemize}

Tux24:
\begin{itemize}
\item Rota para a VLan0 (172.16.20.0) através da gateway 0.0.0.0 (default)
\item Rota para a VLan1 (172.16.20.0) através da gateway 0.0.0.0 (default)
	
\end{itemize}

Uma rota existente permite que seja enviada informação a partir de um determinado tux para um IP destino através de uma \textit{gateway}.


A tabela de reencaminhamento contém outros parâmetros para além dda rota destino e da \textit{gateway}. Pode ser visualizada através do comando "\textbf{route -n}" e contém os seguintes parâmetros:

\begin{description}

\item[Destination -] O destino da rota

\item[Gateway -] O próximo ip por onde a rota passará

\item[NetMask -] Mácara de rede utilizada para encontrar o ID da rede a partir do endereço IP do destino

\item[Flags -] Informações sobre a rota

\item[Metric -] Escolha da melhor rota, caso existam várias

\item[Ref -] Número de referências para a rota

\item[Use -] Contador do número de sucessos e falhas de pesquisas pela rota

\item[Interface -] Placa de rede associada à \textit{gateway}. Neste projeto foram apenas utilizadas as placas eth0 e eth1.

\end{description}

No processo de um tux dar \textit{ping} a outro, é necessário que ambos conheçam o endereço MAC um do outro.
Tal é feito através de mensagens ARP. O tux emissor, ao iniciar a ligação, envia uma mensagem ARP em \textit{broadcast} transmitindo o seu endereço IP e MAC à rede, assim como o endereço IP do tux recetor e, de seguida, o tux com o IP destino envia uma mensagem ARP de volta com o seu endereço MAC.

São também observados dois pacotes ICMP, o de \textit{request} e o de \textit{reply}, dado que estes pacotes são utilizados para verificar se os \textit{tuxys} conseguem transmitir mensagens entre eles. Existem então, para cada rota, um pacote para cada direção de envio para garantir o sucesso da transmissão


Os endereços IP e Mac associados aos pacotes ICMP são os endereços dos \textit{tuxys} de origem e destino, dado que são os endereços necessários para verificar se cada um dos \textit{tuxys} consegue dar \textit{ping} ao outro, que é a principal função de um pacote ICMP. 

\subsection{Experiência 4 - Configuração de um Router Comercial e Implementação de NAT}

Para configurar um \textit{router} estático num \textit{router} comercial, é necessário:

Estabelecer a seguintes ligações por cabo RJ45:
\begin{itemize}
\item RouterGE0 - \textit{Switch} Porta 5
\item ROUTERGE1 - Prateleira Porta 1  
\end{itemize}

De seguida, é necessário utilizar o \textit{router} através do \textit{GTKTerm}. Para isso, é necessário substituir a ligação com o \textit{switch} para o \textit{router}.

É necessário configurar o endereço IP do \textit{router}, o qual pode ser visto no anexo (INSERIR ANEXO AQUI NO FIM)

É também necessário adicionar novas rotas ao \textit{router}, permitindo a comunicação com os restantes \textit{tuxys}. As rotas necessárias são adicionadas através dos comandos que se encontram no anexo (INSERIR INDICE AQUI).

De seguida, retorna-se para o switch e adiciona-se a porta 5 à VLAN 21, tal como é indicado na experiência 2.

Após as alterações, as rotas atuais são:

Tux22:
\begin{itemize}
\item Rota para a VLan0 (172.16.20.0) através da gateway 172.16.21.253
\item Tem uma rota para a VLan1 (172.16.21.0) através da gateway 0.0.0.0 (default)
\item Tem uma rota para o router (172.16.2.0) através da gateway 172.16.21.254
\end{itemize}

Tux23:
\begin{itemize}
\item Rota para a VLan0 (172.16.20.0) através da gateway 0.0.0.0 (default)
\item Tem uma rota para a VLan1 (172.16.20.0) através da gateway 172.16.21.254
\end{itemize}

Tux24:
\begin{itemize}
\item Rota para a VLan0 (172.16.20.0) através da gateway 0.0.0.0 (default)
\item Rota para a VLan1 (172.16.20.0) através da gateway 0.0.0.0 (default)
\item Rota para o router (172.16.2.0) através da gateway 172.16.21.254
\end{itemize}

Router:
\begin{itemize}
\item Rota para a VLan0 (172.16.20.0) através da gateway 172.16.21.253
\item Rota para 0.0.0.0 (default) através da gateway 172.16.1.254
\end{itemize}

Deste modo podemos concluir que os pacotes tentam seguir estas rotas. Caso o tux não conheça a rota para o destino, envia para o \textit{router}, dado que é a rota \textit{default}, e este verifica se o tux24 existe e envia a mensagem. 

Em seguida, para ser possível aceder à \textit{internet}, é necessário configurar o NAT num router comercial. Tal é feito seguindo os passos descritos no anexo (INSERIR INDEX NUMBER).

O NAT \emph{(Network Address Translation)} é capaz de reescrever os endereços de IP de origem de um pacote, quando este passa por um \textit{router}, traduzindo os endereços privados para endereços legais. Tem como objetivo permitir que um computador de uma rede IP privada se conecte à \textit{internet} ou a uma rede pública. Em geral o NAT mapeia vários IPs privados para um enderço exposto publicamente.

\subsection{Experiência 5 - DNS (Domain Name System)}

Para configurar o DNS num host, é necessário alterar o ficheiro \textit{resolv.conf} que se encontra em \textit{/etc/resolv.conf}. Ao editar o ficheiro, deve-se adicionar, na última linha, o seguinte comando:

\begin{lstlisting}[language=bash]
    $ services.netlab.fe.up.pt 172.16.2.1
\end{lstlisting}

Ao gravar as alterações no ficheiro, estamos a indicar que \textit{netlab.fe.up.pt} é o nome do servidor DNS e 172.16.2.1 é o seu endereço IP. É agora possível aceder à \textit{internet} nos \textit{tuxys} 22 e 23.

O DNS troca 2 pacotes, sendo o primeiro enviado do \textit{Host} para o \textit{Server} contendo o \textit{hostname} desejado, requisitando o seu endereço IP. O segundo pacote corresponde a uma resposta do servidor contendo o endereço IP que foi pedido.

\subsection{Experiência 6 - Conexões TCP}

A aplicação abre 2 conexões TCP. A primeira envia os comandos TCP ao servidor e recebe as respostas. A segunda recebe a informação transmitida pelo servidor e envia a resposta ao cliente. A informação de controlo do FTP é transportada na conexão TCP responsável pela troca de comandos.

Uma conexão TCP está dividida em 3 fases distintas: o \emph{Estabelecimento da ligação}, a \emph{Troca de dados} e a \emph{Finalização da ligação}


De modo a gerir os erros de transmissão é usado o mecanismo ARQ TCP com \textbf{Sliding Window}, que utiliza \textbf{acknowledgements numbers} para controlo de erros, ou seja, mensagens cujo único propósito é indicar se uma trama foi recebida corretamente. Possui também um parâmetro \textbf{window size} responsável pelo controlo da congestão de dados e um \textbf{sequence number}, que representa o número do pacote a ser enviado.

O protocolo TCP possui um mecanismo de controlo de congestão, que consiste numa aproximação do número de octetos que é possível transmitir pela rede que está a ser utilizada, estabelecendo valores mínimos de envio de acordo com a janela definida pelo recetor e pela janela de congestão.

É possível verificar a existência deste mecanismo de congestão analisando as taxas de transferência durante o processo de envio de dois ficheiros em simultâneo. Inicialmente a taxa de transferência possui um valor elevado e desce bruscamente assim que o segundo \textit{download} inicia.

Podemos então concluir que o aparecimento de uma segunda conexão TCP funciona como esperado, sendo ambos os ficheiros transmitidos corretamente, porém, utilizando uma menor taxa de transmissão, dado que a taxa de transferência é divida pelos ficheiros.


\section{Conclusões}

Através deste trabalho, foi possível compreender não só o processo de transmissão de um ficheiro segundo o protocolo FTP, mas também todos os passos associados à configuração de uma rede. Durante este processo, o uso do \textit{Wireshark} permitiu-nos entender melhor todos os protocolos pacotes a ser enviados, nomeadamente os pacotes ARP, ICMP, DNS e TCP.

Em suma, foi possível alcançar o objetivo proposto do trabalho, a implementação de uma aplicação que descarregasse um ficheiro de acordo com o protocolo FTP, e a configuração e análise de uma rede, complementando os conhecimentos abordados nas aulas, tanto teóricas como práticas.


\pagebreak

\section{Anexos}

\subsection{Capturas wireshark}

\bigskip

\includegraphics[width=\textwidth]{figura1.PNG}
\captionof{figure}{Mensagens ARP para obter endereços}

\bigskip
\bigskip

\includegraphics[width=\textwidth]{figura2.PNG}
\captionof{figure}{Endereços do pacote ARP enviado pelo tux23}

\bigskip
\bigskip

\includegraphics[width=\textwidth]{figura3.PNG}
\captionof{figure}{Endereços do pacote ARP enviado pelo tux24}

\bigskip
\bigskip

\includegraphics[width=\textwidth]{figura4.PNG}
\captionof{figure}{Endereços MAC e IP nos pacotes ICMP}

\bigskip
\bigskip

\includegraphics[width=\textwidth]{figura5.PNG}
\captionof{figure}{Pacote do tipo ARP}

\bigskip
\bigskip

\includegraphics[width=\textwidth]{figura6.PNG}
\captionof{figure}{Pacote do tipo ICMP}

\bigskip
\bigskip

\includegraphics[width=\textwidth]{figura7.PNG}
\captionof{figure}{Tamanho do pacote enviado}

\pagebreak

\subsection{Sequências de comandos}

\bigskip

\subsubsection{Adicionar a VLan 20}

\begin{lstlisting}[style=bashStyle]
    $ configure terminal
    $ vlan 20
    $ end
    $ show vlan id 20
\end{lstlisting}

\bigskip

\subsubsection{Adicionar Portas 1 e 2 à Vlan 20}

\begin{lstlisting}[style=bashStyle]
    $ configure terminal
    $ interface fastethernet 0/1
    $ switchport mode access
    $ switchport access vlan 20
    $ end
    $ configure terminal
    $ interface fastethernet 0/2            
    $ switchport mode access
    $ switchport access vlan 20
    $ end
\end{lstlisting}

\bigskip

\subsubsection{Adicionar rotas no router}

\begin{lstlisting}[style=bashStyle]
    $ ip route 0.0.0.0 0.0.0.0 172.16.2.254
    $ ip route 172.16.20.0 255.255.255.0 172.16.21.253
\end{lstlisting}

\bigskip

\subsubsection{Adicionar NAT}

\begin{lstlisting}[style=bashStyle]
# Defines Ethernet 0 with an IP address and as a NAT inside interface.
$ conf t            
$ interface fastethernet 0/0
$ ip address 172.16.21.254 255.255.255.0
$ no shutdown
$ ip nat inside        
$ exit
 
# Defines Ethernet 1 with an IP address and as a NAT outside interface.

$ conf t
$ interface fastethernet 0/1
$ ip address 172.16.2.29 255.255.255.0
$ no shutdown
$ ip nat outside       
exit
 
# Defines a NAT pool named ovrld with a range of a single IP  address, 172.16.2.29.
$ ip nat pool ovrld 172.16.2.29 172.16.2.29 prefix 24
# Indicates that any packets received on the inside interface that are permitted by access-list 1 has the source address translated to an address out of the NAT pool named ovrld. Translations are overloaded, which allows multiple inside devices to be translated to the same valid IP address.
ip nat inside source list 1 pool ovrld overload
 
# Access-list 1 permits packets with source addresses ranging from 172.16.20.0 through 172.16.20.7 and 172.16.21.0 through 172.16.21.7.
$ access-list 1 permit 172.16.20.0 0.0.0.7
$ access-list 1 permit 172.16.21.0 0.0.0.7

\end{lstlisting}

\bigskip

\subsubsection{Configurar o IP do router}

\begin{lstlisting}[style=bashStyle]
#Configurar o IP do router

interface fastethernet 0/0                 
ip address 172.16.21.254    255.255.255.0   
no shutdown
exit
show interface fastethernet 0/0

#dar um Ip ao router para poder ligar com a porta GE0, falta dar um ip para comunicacao exterior a partir da porta GE1:

interfacefastethernet 0/1                 
ip address 172.16.2.29    255.255.255.0      
no shutdown
exit
show interface fastethernet 0/1  
\end{lstlisting}

\pagebreak


\subsection{Código}

\subsubsection{ Anexo N - connections.h}

\begin{lstlisting}[style=CStyle]

#ifndef CONNECTION_H
#define CONNECTION_H

#include <sys/socket.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "arguments_parser.h"



int initConnection(char *ip, int port, int *sockfd);

int receiveAnswer(char *buffer);

int sendData(int sockfd, char *command);

int parseIP_Port(char* buffer, char *ip, int *port);

int downloadFile(int socketfd, char * filename);

#endif

\end{lstlisting}

\subsubsection{ Anexo N - connections.c}

\begin{lstlisting}[style=CStyle]

#include "connection.h"

FILE * socketFile;

int initConnection(char *ip, int port, int *sockfd) {
    struct	sockaddr_in server_addr;

    /*server address handling*/
	bzero((char*)&server_addr, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr(ip);	/*32 bit Internet address network byte ordered*/
	server_addr.sin_port = htons(port);		/*server TCP port must be network byte ordered */
    
	/*open an TCP socket*/
	if ((*sockfd = socket(AF_INET, SOCK_STREAM,0)) < 0) {
        perror("socket()");
        return -1;
    }
	/*connect to the server*/
    if(connect(*sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0){
        perror("connect()");
        return -2;
	}

    return 0;
}

int receiveAnswer(char *buffer) {
    do {
        memset(buffer, 0, 512);
        buffer = fgets(buffer, 512, socketFile);
        printf("< %s", buffer);
    } while(buffer[3] != ' ');

    return 0;
}

int sendData(int sockfd, char *command) {
    printf("> %s\n", command);
    int s = send(sockfd, command, strlen(command), 0);

    if(s == 0) {
        printf("sendData: Connection closed\n");
        return -3;
    }
    else if(s == -1) {
        printf("sendData: Error\n");
        return -4;
    }

    return 0;
}

int parseIP_Port(char* buffer, char *ip, int *port) {
    strtok(buffer, "(");
    char *ip1 = strtok(NULL, ",");
    char *ip2 = strtok(NULL, ",");
    char *ip3 = strtok(NULL, ",");
    char *ip4 = strtok(NULL, ",");
    char *port1 = strtok(NULL, ",");
    char *port2 = strtok(NULL, ")");

    sprintf(ip, "%s.%s.%s.%s", ip1, ip2, ip3, ip4);
    *port = atoi(port1) * 256 + atoi(port2);

    return 0;
}

int downloadFile(int socketfd, char * filename) {
    printf("> filename: %s\n", filename);

    int fd = open(filename, O_WRONLY | O_CREAT, 0777);

    if(fd < 0) {
        printf("FD: %i\n", fd);
        printf("Error creating file\n");
        return -5;
    }

    char buffer[1];
    int numBytes;

    while((numBytes = read(socketfd, buffer, 1)) > 0) {
        if(write(fd, buffer, numBytes) < 0) {
            printf("Error writing to file\n");
            return -6;
        }
    }

    if(close(fd) < 0) {
        printf("Error closing file\n");
        return -7;
    }

    return 0;
}

\end{lstlisting}

\pagebreak

\subsubsection{N - argumentsParser.h}

\begin{lstlisting}[style=CStyle]

#ifndef ARGUMENTS_PARSER_H
#define ARGUMENTS_PARSER_H

#include <stdio.h>
#include <string.h>
#include <netdb.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

typedef struct arguments {
    char* user;
    char* password;
    char* host_name;
    char* path;
    char* file_name;
} arguments;

int parseArguments(char* url, arguments *args);
int getIP(char *ip, char *host);

#endif

\end{lstlisting}

\subsubsection{Anexo N - argumentsParser.c}

\begin{lstlisting}[style=CStyle]

#include "arguments_parser.h"

// ftp://[<user>:<password>@]<host>/<url-path>
int parseArguments(char* url, arguments *args) {
    char *ftp = strtok(url, "/"); //ftp:
    char *first = strtok(NULL, "/"); //[<user>:<password>@]<host>
    char *path = strtok(NULL, ""); //<url-path>

    if(strcmp(ftp, "ftp:") != 0) {
        printf("Not using ftp protocol\n");
        return -1;
    }

    char *user = strtok(first, ":");
    char *password = strtok(NULL, "@");

    if(password == NULL) { //No block <user>:<password>
        user = "anonymous";
        password = "anonymous";
        args->host_name = first;
    }
    else {
        args->host_name = strtok(NULL, "");
    }

    args->user = user;
    args->password = password;
    args->path = path;

    char copy[1024];
    strcpy(copy, path);
    char *temp = strtok(copy, "/");
    while (temp != NULL)
    {
        args->file_name = temp;
        temp = strtok(NULL, "/");
    }
    
    return 0;
}

int getIP(char *ip, char *host) {
    struct hostent *h;
    
    if((h=gethostbyname(host)) == NULL) {  
        herror("gethostbyname");
        return -2;
    }

    strcpy(ip, inet_ntoa(*((struct in_addr *)h->h_addr)));
    /*printf("Host name  : %s\n", h->h_name);
    printf("IP Address : %s\n",inet_ntoa(*((struct in_addr *)h->h_addr)));*/

    return 0;
}

\end{lstlisting}

\pagebreak

\subsubsection{ Anexo N - main.c}

\begin{lstlisting}[style=CStyle]

#include <stdio.h>
#include <string.h>
#include "arguments_parser.h"
#include "connection.h"

extern FILE * socketFile;


int main(int argc, char* argv[]) {
    if(argc != 2) {
        printf("Usage: download ftp://[<user>:<password>@]<host>/<url-path>\n");
        return -1;
    }

    arguments args;
    char ipAddress[256];
    char fileName[128];
    int sockfd;
    char answerBuffer[512];
    char command[512];

    if(parseArguments(argv[1], &args) != 0) {
        printf("Error parsing introduced arguments\n");
        return -2;
    }

    strcpy(fileName, args.file_name);

    if(getIP(ipAddress, args.host_name) != 0) {
        printf("< Error getting host IP address\n");
        return -3;
    }

    printf("USER: %s\n", args.user);
    printf("PASS: %s\n", args.password);
    printf("HOST: %s\n", args.host_name);
    printf("PATH: %s\n", args.path);
    printf("FILENAME: %s\n", fileName);
    printf("IP ADDRESS: %s\n", ipAddress);

    if(initConnection(ipAddress, 21, &sockfd) != 0) {
        printf("Error starting connection to server\n");
        return -4;
    }

    socketFile = fdopen(sockfd, "r");
    receiveAnswer(answerBuffer);

    if(answerBuffer[0] == '2') {
        printf("\n< Expecting username...\n");
    }
    else {
        printf("< Error in socket connection\n");
        return -5;
    }

    sprintf(command, "USER %s\r\n", args.user);
    if(sendData(sockfd, command) != 0) {
        return -6;
    }
    receiveAnswer(answerBuffer);

    if(answerBuffer[0] == '3' || answerBuffer[0] == '2') {
        printf("< Expecting password...\n");
    }
    else {
        printf("< Error sending username\n");
        return -7;
    }

    sprintf(command, "PASS %s\r\n", args.password);
    if(sendData(sockfd, command) != 0) {
        return -8;
    }
    receiveAnswer(answerBuffer);

    if(answerBuffer[0] == '2') {
        printf("< Logged in\n\n");
    }
    else {
        printf("< Error sending password\n");
        return -9;
    }

    char *new_ip = malloc(16);
    int new_port;
    int new_sockfd;

    sprintf(command, "PASV \r\n");
    if(sendData(sockfd, command) != 0) {
        return -10;
    }
    receiveAnswer(answerBuffer);

    if(answerBuffer[0] == '2') {
        printf("< Started PASV\n\n");
    }
    else {
        printf("< Error starting PASV\n");
        return -11;
    }

    if(parseIP_Port(answerBuffer, new_ip, &new_port) != 0) {
        return -12;
    }

    printf("< New IP: %s\n", new_ip);
    printf("< New port: %i\n", new_port);

    if(initConnection(new_ip, new_port, &new_sockfd) != 0) {
        printf("Error starting connection to server\n");
        return -13;
    }

    sprintf(command, "RETR %s\r\n", args.path);
    if(sendData(sockfd, command) != 0) {
        return -14;
    }

    receiveAnswer(answerBuffer);

    if(answerBuffer[0] == '1') {
        printf("< RETR correct\n\n");
    }
    else {
        printf("< Invalid file\n");
        return -15;
    }

    if(downloadFile(new_sockfd, fileName) != 0) {
        printf("Error downloading file\n");
        return -16;
    }

    printf("< File %s downloaded\n", fileName);

    if(close(sockfd) < 0) {
        printf("Error closing socket\n");
        return -17;
    }

    if(close(new_sockfd) < 0) {
        printf("Error closing data socket\n");
        return -18;
    }

    return 0;
}

\end{lstlisting}


\end{document}
